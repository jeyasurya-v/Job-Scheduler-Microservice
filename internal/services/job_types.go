package services

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/sirupsen/logrus"

	"job-scheduler/internal/models"
)

// JobExecutor defines the interface for executing different types of jobs
type JobExecutor interface {
	Execute(job *models.Job) error
	GetJobType() models.JobType
}

// EmailNotificationExecutor handles email notification jobs
type EmailNotificationExecutor struct{}

// Execute simulates sending an email notification
func (e *EmailNotificationExecutor) Execute(job *models.Job) error {
	logrus.WithFields(logrus.Fields{
		"job_id":   job.ID,
		"job_name": job.Name,
		"job_type": job.JobType,
	}).Info("Starting email notification job")

	// Extract configuration
	recipient := "user@example.com"
	subject := "Scheduled Notification"
	body := "This is a scheduled email notification."

	if job.Config != nil {
		if r, ok := job.Config["recipient"].(string); ok {
			recipient = r
		}
		if s, ok := job.Config["subject"].(string); ok {
			subject = s
		}
		if b, ok := job.Config["body"].(string); ok {
			body = b
		}
	}

	// Simulate email sending delay
	time.Sleep(1 * time.Second)

	// Log the "email" details
	logrus.WithFields(logrus.Fields{
		"job_id":    job.ID,
		"recipient": recipient,
		"subject":   subject,
		"body":      body,
	}).Info("Email sent successfully")

	return nil
}

// GetJobType returns the job type
func (e *EmailNotificationExecutor) GetJobType() models.JobType {
	return models.JobTypeEmailNotification
}

// DataProcessingExecutor handles data processing jobs
type DataProcessingExecutor struct{}

// Execute simulates data processing
func (d *DataProcessingExecutor) Execute(job *models.Job) error {
	logrus.WithFields(logrus.Fields{
		"job_id":   job.ID,
		"job_name": job.Name,
		"job_type": job.JobType,
	}).Info("Starting data processing job")

	// Extract configuration
	processingTime := 5
	dataSize := "1MB"
	operation := "transform"

	if job.Config != nil {
		if pt, ok := job.Config["processing_time_seconds"].(float64); ok {
			processingTime = int(pt)
		}
		if ds, ok := job.Config["data_size"].(string); ok {
			dataSize = ds
		}
		if op, ok := job.Config["operation"].(string); ok {
			operation = op
		}
	}

	logrus.WithFields(logrus.Fields{
		"job_id":           job.ID,
		"data_size":        dataSize,
		"operation":        operation,
		"processing_time":  processingTime,
	}).Info("Processing data...")

	// Simulate data processing
	time.Sleep(time.Duration(processingTime) * time.Second)

	logrus.WithFields(logrus.Fields{
		"job_id":     job.ID,
		"data_size":  dataSize,
		"operation":  operation,
	}).Info("Data processing completed successfully")

	return nil
}

// GetJobType returns the job type
func (d *DataProcessingExecutor) GetJobType() models.JobType {
	return models.JobTypeDataProcessing
}

// ReportGenerationExecutor handles report generation jobs
type ReportGenerationExecutor struct {
	reportsDir string
}

// NewReportGenerationExecutor creates a new report generation executor
func NewReportGenerationExecutor(reportsDir string) *ReportGenerationExecutor {
	return &ReportGenerationExecutor{
		reportsDir: reportsDir,
	}
}

// Execute generates a simple text report
func (r *ReportGenerationExecutor) Execute(job *models.Job) error {
	logrus.WithFields(logrus.Fields{
		"job_id":   job.ID,
		"job_name": job.Name,
		"job_type": job.JobType,
	}).Info("Starting report generation job")

	// Extract configuration
	reportType := "daily_summary"
	format := "txt"
	includeCharts := false

	if job.Config != nil {
		if rt, ok := job.Config["report_type"].(string); ok {
			reportType = rt
		}
		if f, ok := job.Config["format"].(string); ok {
			format = f
		}
		if ic, ok := job.Config["include_charts"].(bool); ok {
			includeCharts = ic
		}
	}

	// Ensure reports directory exists
	if err := os.MkdirAll(r.reportsDir, 0755); err != nil {
		return fmt.Errorf("failed to create reports directory: %w", err)
	}

	// Generate report filename
	timestamp := time.Now().Format("20060102_150405")
	filename := fmt.Sprintf("%s_%s_%s.%s", reportType, job.ID.String()[:8], timestamp, format)
	filepath := filepath.Join(r.reportsDir, filename)

	// Generate report content
	content := fmt.Sprintf(`Report: %s
Generated: %s
Job ID: %s
Job Name: %s

Summary:
- Report Type: %s
- Format: %s
- Include Charts: %t
- Generated at: %s

This is a sample report generated by the job scheduler.
In a real implementation, this would contain actual data and analysis.

Sample Data:
- Total Records Processed: 1,234
- Success Rate: 98.5%%
- Average Processing Time: 2.3 seconds
- Errors Encountered: 18

End of Report
`, reportType, time.Now().Format("2006-01-02 15:04:05"), job.ID, job.Name,
		reportType, format, includeCharts, time.Now().Format("2006-01-02 15:04:05"))

	// Write report to file
	if err := ioutil.WriteFile(filepath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report file: %w", err)
	}

	logrus.WithFields(logrus.Fields{
		"job_id":         job.ID,
		"report_type":    reportType,
		"format":         format,
		"include_charts": includeCharts,
		"file_path":      filepath,
	}).Info("Report generated successfully")

	return nil
}

// GetJobType returns the job type
func (r *ReportGenerationExecutor) GetJobType() models.JobType {
	return models.JobTypeReportGeneration
}

// HealthCheckExecutor handles health check jobs
type HealthCheckExecutor struct {
	httpClient *http.Client
}

// NewHealthCheckExecutor creates a new health check executor
func NewHealthCheckExecutor(timeout time.Duration) *HealthCheckExecutor {
	return &HealthCheckExecutor{
		httpClient: &http.Client{
			Timeout: timeout,
		},
	}
}

// Execute performs a health check by pinging a URL
func (h *HealthCheckExecutor) Execute(job *models.Job) error {
	logrus.WithFields(logrus.Fields{
		"job_id":   job.ID,
		"job_name": job.Name,
		"job_type": job.JobType,
	}).Info("Starting health check job")

	// Extract configuration
	url := "https://httpbin.org/status/200"
	expectedStatus := 200

	if job.Config != nil {
		if u, ok := job.Config["url"].(string); ok {
			url = u
		}
		if es, ok := job.Config["expected_status"].(float64); ok {
			expectedStatus = int(es)
		}
	}

	logrus.WithFields(logrus.Fields{
		"job_id":          job.ID,
		"url":             url,
		"expected_status": expectedStatus,
	}).Info("Performing health check...")

	// Perform HTTP request
	resp, err := h.httpClient.Get(url)
	if err != nil {
		return fmt.Errorf("health check failed - request error: %w", err)
	}
	defer resp.Body.Close()

	// Check status code
	if resp.StatusCode != expectedStatus {
		return fmt.Errorf("health check failed - expected status %d, got %d", expectedStatus, resp.StatusCode)
	}

	logrus.WithFields(logrus.Fields{
		"job_id":      job.ID,
		"url":         url,
		"status_code": resp.StatusCode,
		"status":      resp.Status,
	}).Info("Health check completed successfully")

	return nil
}

// GetJobType returns the job type
func (h *HealthCheckExecutor) GetJobType() models.JobType {
	return models.JobTypeHealthCheck
}
